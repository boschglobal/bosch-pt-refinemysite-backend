/*
 * ************************************************************************
 *
 *  Copyright:       Robert Bosch Power Tools GmbH, 2018 - 2021
 *
 * ************************************************************************
 */
package com.bosch.pt.csm.cloud.gradle.plugin.i18n

import java.io.File
import java.io.FileInputStream
import java.io.IOException
import java.util.regex.Pattern
import org.apache.commons.io.FileUtils.writeStringToFile
import org.gradle.api.DefaultTask
import org.gradle.api.logging.Logging
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.SkipWhenEmpty
import org.gradle.api.tasks.TaskAction

open class MessagesKeyGenerator : DefaultTask() {

  @OutputFile var outputFile: File? = null

  @SkipWhenEmpty @InputFile var inputFile: File? = null

  @TaskAction
  @Throws(IOException::class)
  fun generateMessagesKeyKotlin() =
      try {
        FileInputStream(inputFile!!).use {
          val builder = StringBuilder().also { addHeader(it, className, packageName) }
          OrderedProperties()
              .apply { load(it) }
              .forEach { key, value -> createLine(builder, key.toString(), value.toString()) }
          addFooter(builder)
          writeStringToFile(outputFile, builder.toString(), ENCODING)
        }
      } catch (ex: IOException) {
        LOGGER.error("I18N plugin failed to load file {}.", inputFile!!.absolutePath)
        throw ex
      }

  private fun addHeader(buffer: StringBuilder, className: String, packageName: String) =
      buffer.apply {
        append("package $packageName$LF")
        append("// ---------------------------------$LF")
        append("// WARNING: Generated by Gradle task - NOT TO BE EDITED$LF")
        append("// ---------------------------------$LF$LF")
        append("object $className {$LF$LF")
      }

  private fun createLine(buffer: StringBuilder, key: String, value: String) =
      buffer.apply {
        append("    /**\n     * $value\n     */$LF")
        append("    const val ${toJavaConstantName(key)} = \"$key\"$LF$LF")
      }

  private fun addFooter(buffer: StringBuilder) = buffer.append("}$LF")

  private fun toJavaConstantName(value: String): String {
    val builder = StringBuilder()
    var lowercasePrevious = false

    for (i in value.indices) {
      val character = value[i]

      if (Character.isLowerCase(character)) {
        lowercasePrevious = true
        builder.append(Character.toUpperCase(character))
      } else if (Character.isUpperCase(character)) {
        if (lowercasePrevious) {
          lowercasePrevious = false
          builder.append('_').append(character)
        } else {
          builder.append(character)
        }
      } else if (Character.isDigit(character)) {
        check(i != 0) { "Constant names must not start with a digit" }
        builder.append(character)
      }
    }

    return builder.toString()
  }

  private val className: String
    get() {
      val matcher = OUTPUT_REGEX.matcher(outputFile!!.absolutePath)

      return if (matcher.find()) {
        matcher.group(2)
      } else {
        error("Output file not match regex $OUTPUT_REGEX")
      }
    }

  private val packageName: String
    get() {
      val matcher = OUTPUT_REGEX.matcher(outputFile!!.absolutePath)

      return if (matcher.find()) {
        matcher.group(1).replace("/", ".")
      } else {
        error("Output file not match regex $OUTPUT_REGEX")
      }
    }

  companion object {
    private const val ENCODING = "UTF-8"

    private val LF = System.lineSeparator()
    private val LOGGER = Logging.getLogger(MessagesKeyGenerator::class.java)
    private val OUTPUT_REGEX = Pattern.compile(".*src/main/kotlin/(.*)/(.*).kt")
  }
}
